#闭包和高阶函数

> 在JavaScript中，许多模式都可以用闭包和高阶函数来实现。

- <a href="#no1">3.1 闭包</a>
- <a href="#no2">3.2 高阶函数</a>

##<a name="no1">3.1 闭包</a>

> 对于JavaScript程序员来说，闭包（`closure`）是一个难懂又必须征服的概念。闭包的形成与变量的作用域及变量的生存周期密切相关。

###3.1.1 变量的作用域

> 变量的作用域，就是指变量的有效范围。

**当在函数中声明一个变量的时候，如果该变量的前面没有带上关键字`var`，这个变量就会变成全局变量。另外一种情况是用`var`关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。**

	var func = function(){
      var a = 1;
      console.log(a); //输出： 1
    }

    func();
    console.log(a); //输出：Uncaught ReferenceError: a is not defined

#**变量的搜索是从内到外而非从外到内的。**

	var a = 1;

    var func1 = function(){
      var b = 2;
      var func2 = function(){
        var c = 3;
        console.log(b); //输出：2
        console.log(a); //输出：1
      }
      func2();
      console.log(c); //输出：Uncaught ReferenceError: a is not defined
    }

    func1();

###3.1.2 变量的生存周期

- 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。

- 对于在函数内用`var`关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁：
#
	var func = function(){
      var a = 1;	// 推出函数后局部变量 a 将被销毁
      console.log(a);
    }

    func();

现在来看下面这段代码：

	var func = function(){
      var a = 1;
      return function(){
        a++;
        console.log(a);
      }
    };

    var f = func();

    f();  // 输出：2
    f();  // 输出：3
    f();  // 输出：4
    f();  // 输出：5

#

	<!DOCTYPE html>
	<html lang="en">
	<head>
	  <meta charset="UTF-8">
	  <title>变量的生存周期</title>
	</head>
	<body>
	  <div>1</div>
	  <div>2</div>
	  <div>3</div>
	  <div>4</div>
	  <div>5</div>
	
	  <script>
	    var nodes = document.getElementsByTagName('div');
	
	    for(var i = 0,len = nodes.length; i < len; i++){
	      nodes[i].onclick = function(){
	        console.log(i);	// 不管点击哪个div都是返回5
	      }
	    }
	  </script>
	</html>

#
	for(var i = 0,len = nodes.length; i < len; i++){
      (function(i){
        nodes[i].onclick = function(){
          console.log(i); //返回正确的索引值
        }
      })(i);
    }
#

	var Type = {};

    for(var i = 0,type; type = ['String','Array','Number'][i++];){
      (function(type){
        Type['is' + type] = function(obj){
          return Object.prototype.toString.call(obj) === '[object '+ type +']';
        }
      })(type);
    }

    console.log(Type.isArray([])); // true
    console.log(Type.isNumber(1)); // true
    console.log(Type.isString('str')); // true


###3.1.3 闭包的更多作用

 1. 封装变量
 2. 延续局部变量的寿命

###3.1.4 闭包和面向对象设计

下面来看看这段跟闭包相关的代码：
	
	var extent = function(){
      var value = 0;
      return {
        call: function(){
          value++;
          console.log(value);
        }
      }
    };

    var extent = extent();

    extent.call();  //输出： 1
    extent.call();  //输出： 2
    extent.call();  //输出： 3  

如果换成面向对象的写法：

	var extent = {
      value: 0,
      call: function(){
        this.value++;
        console.log(this.value);
      }
    };

    extent.call(); //输出：1
    extent.call(); //输出：2
    extent.call(); //输出：3

或者

	var Extent = function(){
      this.value = 0;
    };

    Extent.prototype.call = function(){
      this.value++;
      console.log(this.value);
    };

    var extent = new Extent();

    extent.call();  //输出：1
    extent.call();  //输出：2
    extent.call();  //输出：3

###3.1.5 用闭包实现命令模式

	<!DOCTYPE html>
	<html lang="en">
	<head>
	  <meta charset="UTF-8">
	  <title>用闭包实现命令模式</title>
	</head>
	<body>
	  <div id="execute">打开</div>
	  <div id="undo">关闭</div>
	
	  <script>
	    var Tv = {
	      open: function(){
	        console.log('打开电视机');
	      },
	      close: function(){
	        console.log('关闭电视机');
	      }
	    };
	
	    var creatCommand = function(receiver){
	      var execute = function(){
	        return receiver.open(); //执行命令，打开电视机
	      }
	
	      var undo = function(){
	        return receiver.close();  //执行命令，关闭电视机
	      }
	
	      return {
	        execute: execute,
	        undo: undo
	      }
	    };
	
	    var setCommand = function(command){
	      document.getElementById('execute').onclick = function(){
	        command.execute();  //输出：打开电视机
	      }
	
	      document.getElementById('undo').onclick = function(){
	        command.undo();  //输出：关闭电视机
	      }
	    };
	
	    setCommand(creatCommand(Tv));
	  </script>
	</html>

###3.1.6 闭包与内存管理
> 可手动设置变量为`null`，防止内存泄漏。

##<a name="no2">3.2 高阶函数</a>

**高阶函数是指至少满足下列条件之一的函数**

 1. 函数可以作为参数被传递。
 2. 函数可以作为返回值输出。

###3.2.1 函数作为参数传递

- 回调函数
- `Array.prototype.sort`

###3.2.2 函数作为返回值输出

- 判断数据的类型
- `getSingle`

###3.2.3 高阶函数实现AOP

###3.2.4 高阶函数的其他应用

**1. currying**
#
	var monthlyCost = 0;

	var cost = function(money){
	monthlyCost += money;
	}
	
	cost(100);  // 第1天开销
	cost(200);  // 第2天开销
	cost(300);  // 第3天开销
	
	console.log(monthlyCost); //输出：600
#
	var cost = (function(){
    var args = [];

		return function(){
		  if(arguments.length === 0){
		    var money = 0;
		    for(var i = 0, l = args.length; i < l; i++){
		      money += args[i];
		    }
		    return money;
		  }else{
		    [].push.apply(args,arguments);
		  }
		}
	});
	
	cost(100);  //未真正求值
	cost(200);  //未真正求值
	cost(300);  //未真正求值
	
	console.log(cost());  // 求值并输出：600

#
	var currying = function(fn){
	    var args = [];
	
	    return function(){
	        if(arguments.length === 0){
	            return fn.apply(this, args);
	        }else{
	            [].push.apply(args, arguments);
	            return arguments.callee;
	        }
	    }
	};
	
	var cost = (function(){
	    var money = 0;
	
	    return function(){
	        for(var i = 0, l = arguments.length; i < l; i++){
	            money += arguments[i];
	        }
	        return money;
	    }
	})();
	
	var cost = currying(cost);  //转化成 currying 函数
	
	cost(100);  //未真正求值
	cost(200);  //未真正求值
	cost(300);  //未真正求值
	
	console.log(cost());  // 求值并输出：600
#
**2. uncurrying**

p51