#面向对象的JavaScript

- <a href="#no1">1.1 动态类型语言和鸭子类型</a>
- <a href="#no2">1.2 多态</a>
- <a href="#no3">1.3 封装</a>



##<a name="no1">1.1 动态类型语言和鸭子类型</a>
> 编程语言按照数据类型大体可以分为两类：一类是静态类型语言，另一类是动态类型语言。

- 静态类型语言在编译时便已确定变量的类型。
- 动态类型怨言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。


##<a name="no2">1.2 多态</a>
> 多态的实际含义是 ： 同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一消息的时候，这些对象会根据这个消息分别给出不同的反馈。

###1.2.1 一段“多态”的JavaScript代码

	var makeSound = function(animal){
      if(animal instanceof Duck){
        console.log('嘎嘎嘎');
      }else if(animal instanceof Chicken){
        console.log('咯咯咯');
      }
    }

    var Duck = function(){};
    var Chicken = function(){};

    makeSound(new Duck());  //嘎嘎嘎
    makeSound(new Chicken());  //咯咯咯

**多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来。**

###1.2.2 对象的多态性

	// 把不变的部分隔离出来
    var makeSound = function(animal){
      animal.sound();
    }

    // 把可变的部分各自封装起来
    var Duck = function(){};
    Duck.protype.sound = function(){
      console.log('嘎嘎嘎');
    }

    var Chicken = function(){};
    Chicken.protype.sound = function(){
      console.log('咯咯咯');
    }

    var Dog = function(){};
    Dog.protype.sound = function(){
      console.log('汪汪汪');
    }

    makeSound(new Duck());  //嘎嘎嘎
    makeSound(new Chicken());  //咯咯咯
    makeSound(new Dog());  //汪汪汪

###1.2.3 类型检查和多态

> 类型检查是在表现出对象多态性之前的一个绕不开的话题,但JavaScript是一门不必进行类型检查的动态类型语言。

###1.2.4 使用继承得到多态效果
> 使用继承来得到多态效果，是让对象表现出多态性的最常用的手段。继承通常包括实现继承和借口继承。

###1.2.5 JavaScript的多态
> JavaScript作为一门动态类型语言，与生俱来的有多态性。

###1.2.6 多态在面向对象程序设计中的作用
> 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。

###1.2.7 设计模式与多态
> 详见《JavaScript设计模式与开发实践》P11


##<a name="no3">1.3 封装</a>

**封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。这里不仅包括封装数据和封装实现，还包括封装类型和封装变化。**

###1.3.1 封装数据
> 在JavaScript中，我们只能以来变量的作用域来实现封装特性，而且只能模拟出 `public` 和 `private` 这两种封装性。

	var myObject = (function(){
	  var _name = 'sven'; //私有（private）变量
	  return {
	    getName: function(){  //公开（public）方法
	      return _name;
	    }
	  }
	})();
	
	console.log(myObject.getName());  //sven
	console.log(myObject._name);  //undefined

###1.3.2 封装实现

###1.3.3 封装类型

###1.3.4 封装变化


##<a name="no4">1.4 原型模式和基于原型继承的JavaScript对象系统</a>

###1.4.1 使用克隆的原型模式

	var Plane = function(){
      this.blood = 100;
      this.attackLevel = 1;
      this.defenseLevel = 1;
    }

    var plane = new Plane();
    plane.blood = 500;
    plane.attackLevel = 10;
    plane.defenseLevel = 7;

    var clonePlane = Object.create(plane);
    console.log(clonePlane);  //输出： Object{blood:500,attackLevel:10,defenseLevel:7}

    // 在不支持Object.create方法的浏览器中，则可以使用以下代码：
    Object.create = Object.create || function(obj){
      var F = function(){};
      F.prototype = obj;
      return new F();
    }
###1.4.2 - 1.4.6
> 详见《JavaScript设计模式与开发实践》P15 - P23